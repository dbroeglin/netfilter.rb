module Netfilter
  class Rule
    attr_reader :options
    attr_reader :chain
    
    NFOPTS = {
      :src => '-s',
      :dst => '-d',
      :protocol => { :opt => '-p', :aliases => :p },
      :state => { :opt => '-m state --state', :upcase => true },
      :dport => '--dport',
      :sport => '--sport',
      :dports => '--dports',
      :sports => '--sports',
      :in => '-i',
      :out => '-o',
      :prefix => { :opt => '-j LOG --log-prefix', :quote => true },
      :action => { :opt => '-j', :upcase => true },
      :jump => '-j',
      :limit => { :opt => '-m limit --limit', :aliases => :limit_rate },
      :burst => { :opt => '-m limit --limit-burst', :aliases => :limit_burst },
      :pkt_type => '-m pkttype --pkt-type',
      :policy => {:opt => '-P', :upcase => true},
      :reject_with => { :opt => '-j REJECT --reject-with' },
      :cmdline => '',
    }

    def initialize(options = {})
      @chain = options.delete(:chain)
      @options = options
    end

    def rules
      options.combinate.collect { |o| Rule.new(o).to_nfargs }
    end

    def to_nfargs
      s = []
      options.keys.each do |k|
        val = options[k]

        s << render_nfarg(k,options[k])
      end
      s.join(" ")
    end

    private

    def render_nfarg(search_key, value)
      if value.respond_to?(:to_nfcmdline)
        return value.to_nfcmdline(find_nfopt(search_key))
      end

      if value.respond_to?(:to_nfarg)
        value = value.to_nfarg
      end
      

      if options = find_nfopt(search_key)
        if options[:quote]
          value = "\"#{value}\""
        else
          value = value.to_s.gsub('_','-')
        end
        opt = options[:opt]
        value = value.to_s.upcase if options[:upcase]
        "#{opt} #{value}"
      else
        nil
      end
    end

    def find_nfopt(search_key)
      NFOPTS.keys.each do |k|
        if NFOPTS[k].is_a? Hash
          options = NFOPTS[k]
          keys = [k, options[:aliases]].flatten
        else
          keys = [k]
          options = { :opt => NFOPTS[k]}
        end
        return options if keys.include? search_key
      end
      nil
    end
    
  end

  def filter
    @filter_table ||= FilterTable.new
  end

  def render_netfilter
    out = []
    out << "# Generated by firewall.rb on #{Time.now}"
    [filter].each do |table|
      out << "*#{table.name}"
      table.chains.each do |chain|
        out << chain.to_nfheader
        chain.rules.each do |rule|
          out << rule.join(" ")
        end
      end
    end
    puts out.join("\n")
  end
end

